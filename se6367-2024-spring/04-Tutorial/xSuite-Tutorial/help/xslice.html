<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
  <head>
    <meta http-equiv="content-type" content="text/html; charset=ISO-8859-1">
    <title>
      xSlice for program debugging
    </title>
	<link rel=stylesheet href="style.css" type="text/css" media=screen>
  </head>
  <body>
	<div id="wrap"> 
		<a href="coverpage.html">[Top]</a> 
		<a href="xvue.html">[Prev]</a>
		<a href="appendixB.html">[Next]</a> 
		<a href="sqatoolIX.html">[Index]</a> 
		<a href="sqatoolTOC.html">[TOC]</a>
	<hr>
    <br>
    <h1>
      <a name="770300"></a>
    </h1>
    <h1>
      <a name="780605"></a>
    </h1>
    <h1>
      <a name="770301">Chapter 13<br>
      <br>
      xSlice: A Tool for Program Debugging<br>
      </a>
    </h1>
    <p>
      <a name="769964"><em>xSlice</em> is the program
      debugger in the Toolsuite. It automates many tedious tasks that
      developers otherwise must perform manually while debugging their code.
      <em>xSlice</em> helps developers to focus on just
      the relevant code by eliminating the typical <em>conceptual clutter</em>
      of debugging. It makes the relevant pieces of the code stand out in no
      time with its intelligent analysis and state-of-the-art graphical
      interface.</a>
    </p>
    <hr>
    <h2>
      <a name="773230">13.1 Background</a>
    </h2><a name="773793">In this section we describe an execution slicing
    tool, <em>xSlice</em>, and show the usefulness of
    slicing in locating program faults.</a>
    <p>
      <a name="775272">In general, program slicing can be categorized as
      <em>static</em> slicing and <em>dynamic</em> slicing. A static slice is a
      set of statements of a program which <em>might</em> affect the value of a
      particular output or the value of a variable instance; whereas a dynamic
      slice is the set of statements which <em>did</em> affect the value of the
      output upon execution of a particular input. A dynamic slice with respect
      to the output variables gives us the statements that are not only
      executed but also have an impact on the program output under that test
      case. Although both static and dynamic slices can be used as an
      abstraction to help programmers in locating faults, a static slice is
      less effective because it, in general, requires that a larger portion of
      program code be examined than does a dynamic slice.</a>
    </p>
    <p>
      <a name="775452">Collecting dynamic slices may consume excessive time and
      file space. <em>xSlice</em> computes an execution
      slice instead. An execution slice is the set of statements executed under
      a test case. Since not every statement that is executed under a test case
      has an effect on the program output for that test case, some statements
      in an execution slice may not be in the corresponding dynamic slice. This
      makes an execution slice a super set of a dynamic slice. Based on
      execution slices, <em>xSlice</em> also computes
      an execution <em>dice</em> which is the set difference of two execution <em>slices</em>. In
      <em>xSlice</em>, an execution slice is the set of
      a program's blocks or decisions executed by a test input. Similarly, an
      execution dice is the set of blocks or decisions in one execution slice
      which do not appear in an other execution slice(s).</a>
    </p>
    <p>
      <a name="775492">The strategy for fault localization in <em>xSlice</em> is as follows. 
	  Suppose a piece of software has
      worked successfully for some time, so many error-free test cases are
      available. Then a problem is reported from the field with a new test case
      that exhibits a failure. The fault will be in the execution slice of the
      new test that exhibits the failure. It seems likely that the fault is not
      in the execution slices of the similar tests that do not exhibit the
      failure. We refer to the error-free test cases as <em>successful</em>
      tests and those that cause a failure as <em>failed</em> tests. A good
      starting point for locating the fault is to look at code that is in the
      failed execution slice but not in the successful ones, i.e., the
      execution dice obtained by subtracting the successful execution slices
      from the failed execution slice. Code in the resulting dice is
      highlighted in red as the most likely location of the fault. Code in the
      failed execution slice but not in the dice is highlighted in a different
      color with its likelihood of containing the fault inversely proportional
      to the number of successful tests which also execute it.</a>
    </p>
    <p>
      <a name="784911">Execution dices obtained depend on the test cases used.
      Different dices may be generated by different sets of successful and
      failed tests. In order to have the best results one should try to
      identify successful tests that are as similar as possible to the failed
      tests in order to filter out as much irrelevant code as possible.</a>
    </p>
    <h2>
      <a name="784945">13.2 A Tutorial</a>
    </h2><a name="784960">The use of <em>xSlice</em> is
    most easily understood by an example. In this section we use the same
    wordcount program as used before to illustrate how the basic features of
    <em>xSlice</em> can be used in locating program
    faults. To copy these files, create a new directory, <em>cd</em> to it, and
    copy the contents of the directory in which the tutorial files are
    installed into the new directory. For the illustrations in this chapter, we
    will use (1) three <em>c</em> files: <em>main_err.c</em>, <em>main.c</em>
    and <em>wc.c</em>, (2) three data files: <em>input1</em>, <em>input2</em>,
    and <em>input3</em> and (3) a <em>Makefile</em>. The file
    <em>main_err.c</em> is an erroneous version of <em>main.c</em> with a fault
    which is to be found. Follow the instructions in</a> <a href=
    "appendixB.html#1001045">Appendix A, <em>Platform Specific
    Information</em></a> to compile <em>wordcount</em> without <em>atac</em>
    using <em>main.c</em>; delete the object files; and build <em>wc_err(.exe)</em>
    with <em>atac</em> using <em>main_err.c</em>.
    <p>
      <a name="785004">After the compilation, two <em>.atac</em> files
		  (<em>main_err.atac</em> for <em>main_err.c</em> and <em>wc.atac</em> for
		  <em>wc.c</em>), one <em>.atacp</em> file
		  (<em>wc_err.atacp</em>), and the executable <em>wc_err(.exe)</em> are created.
		  Note, one <em>.atac</em> file is created for each instrumented
		  <em>.c</em> file, i.e., the <em>.c</em> files compiled with ATAC, and one
		  <em>.atacp</em> file is created for each executable generated during the build process.</a>
    </p>


    <p>
    Compile two versions of the wordcount, wordcount (no bug), wc_err (with bug):
    </p>
    <pre>
		prompt:> make clean
		prompt:> make wordcount
		prompt:> make wc_err CC="atac cc"
    </pre>
	
	<p>
	Unset the <em>ATAC_TRACE</em> environment variable, if it is set, using the following command 
	(on Windows):
	</p>

	<pre>
		prompt:> set ATAC_TRACE=
	</pre>
	
    <p>
      <a name="780617">To find where the fault is, we need some successful
      tests and some tests that fail. Let us run <em>wc_err</em> on the first
      test:</a>
    </p>
    <pre>
		prompt:&gt; ./wc_err input1  (<em>wc_err.1</em>)<br>
	</pre>
	This should produce the following output:
    <pre>
		1       4       19      input1        
		1       4       19      total
	</pre>
	<p>
		<a name="785056">Repeat the same test with wordcount. The same output is
		generated which implies that test <em>wc_err.1</em> does not distinguish the
		behavior of <em>wc_err</em> from that of wordcount. Hence, it is a successful
		test.</a>
	</p>
    <p>
      <a name="785170">We now run the second test on <em>wc_err</em> by
      entering:</a>
    </p>
    <pre>
		prompt:&gt; ./wc_err -w input1   (<em>wc_err.2</em>)<br>
	</pre>	
	The output looks like:
    <pre>
		4       input1
		4       total
	</pre>	
	<a name="785102">This is the same as that obtained from executing:</a>
    <pre>
		prompt:&gt; ./wordcount -w input1 <br>
	</pre>
	<a name="786260">This implies that test <em>wc_err.2</em> is another successful test.</a>
    <p>
      <a name="785172">Let us run another test by:</a>
    </p>
    <pre>
		prompt:&gt; ./wc_err -w &lt; input1   (<em>wc_err.3</em>)<br>
	</pre>
	<a name="785153">An output with an empty line is generated. Executed the same test case using wordcount, the same test produces the following output:</a>
    <pre>
		prompt:&gt; ./wordcount -w &lt; input1
		prompt:&gt; 4
	</pre>
	<p>
		<a name="785225">This output differs from that generated by
		<em>wc_err</em> indicating test <em>wc_err.3</em> is a failed test. So far, we
		have run three tests. On two of them <em>wc_err</em> and wordcount produce the
		same outputs, whereas on the third test different outputs are observed.</a>
	</p>
    <p>
      <a name="785190">Next, we invoke the graphical user interface of the
      Toolsuite by entering the following command:</a>
    </p>
    <pre>
		prompt:&gt; xsuite wc_err.atacp wc_err.trace
	</pre>
	<p>
		<a name="774592">Then pull down the "<em>Coverage</em>" menu and select the "<em>xSlice"</em> option.</a>
		<a href="xslice.html#774592">Figure 13-1</a> shows the main window of
		<em>xSlice</em>.
	</p>
    
    <a name="774586"></a>
	<div class="figure">			  
		<a href="xslice.frm.anc.gif"><img src="xslice.frm.anc.gif"></a>             
		<div>Figure 13-1 The initial display of the main <em>xSlice window</em></div>
	</div>
    
	<p>
		<a name="785224"></a><a name="774774">The test cases we have run are 
		displayed in the lower right pane of the main window. Mark <em>wc_err.1</em>
		and <em>wc_err.2</em> as successful tests by clicking on the leftmost
		square next to them. A check mark appears in the square. In addition,
		<em>wc_err.1</em> and <em>wc_err.2</em> are highlighted in green.
		Similarly, you can mark <em>wc_err.3</em> as a failed test by clicking on
		the square immediately to the left of <em>wc_err.3</em>. A check mark appears
		in the square and <em>wc_err.3</em> is highlighted in red. The resulting
		test case window appears in</a> <a href="xslice.html#774774">Figure
		13-2</a>.
	</p>
    
	<a name="774768"></a>
	<div class="figure">
		<a href="xslice.frm.anc1.gif"><img src="xslice.frm.anc1.gif"></a>
		<div>Figure 13-2 The updated test case window</div>
	</div>
              
	<p>		  
		<a name="774839">The lower left "<em>Summary</em>" 
		pane displays the results of tests as
		shown in</a> <a href="xslice.html#774839">Figure 13-3</a>. 
		To see the source display of the corresponding file, double click on a file name in the
		summary pane. You can have the summary displayed in other formats by
		selecting from the drop down and choosing "<em>by-type</em>" or the "<em>by-function</em>" button
		in the middle button bar. To continue with this tutorial, be sure
		"<em>by-file</em>" is selected.
	</p>
    
    <a name="774836"></a>              
    <div class="figure">
		<a href="xslice.frm.anc2.gif"><img src="xslice.frm.anc2.gif"></a>
        <div>Figure 13-3 A block slicing summary <em>by-file</em> over all 
            selected test cases</div>
    </div>
	
    <p>
      <a name="786223">As discussed in</a> <a href="xslice.html#773230">Section
      13.1</a>, code in the execution dice is highlighted in red as the most
      likely location of the fault. Code in the failed execution slice but not
      in the dice is highlighted in a different color with its likelihood of
      containing the fault inversely proportional to the number of successful
      tests which also execute it. In our case, code in red with the highest
      priority 3 is executed by the failed test <em>(wc_err.3)</em> but not the
      successful tests (neither <em>wc_err.1</em> nor <em>wc_err2</em>). Code
      with a priority 2 is executed by the failed test <em>(wc_err.3)</em> and
      one of the successful tests (<em>wc_err.1</em> or
      <em>wc_err.2</em>). Code with a priority 1 is executed by the failed test
      <em>(wc_err.3)</em> and both successful tests (<em>wc_err.1</em> and
      <em>wc_err.2</em>). Finally, code with no highlighting is the code
      that is not executed by any of the failed tests <em>(wc_err.3</em>, in
      our case). Finally, code that is not executed by all of the failed tests 
	  is not highlighted. Note that <em>only those pieces
      of code that are executed by all of the failed tests get a nonzero
      priority</em> (i.e., is highlighted). However, if
      the program under test has multiple faults with each detected by
      different tests, you should try to locate one fault at a time. That is,
      while computing the execution slice or dice, do not select failed tests
      from different faults at the same time. Otherwise, the highlighted code
      will miss some of the faults. Those pieces of code that are not executed
      by any of the failed tests are not highlighted
	  irrespective of whether or not they are executed by any (or
      some, or all) successful tests.
    </p>
    <p>
      <a name="785488">The highest priority among all pieces of code in a file
      gets reflected in the corresponding entry in the summary pane. As
      in</a> <a href="xslice.html#774839">Figure 13-3</a>, <em>main_err.c</em>
      is in red because some of its code has a priority 3, but the highest
      priority <em>wc.c</em> has is 1, so it is displayed in the color of
      priority 1. In other words, <em>main_err.c</em> (but not <em>wc.c</em>)
      has blocks that are executed by the failed test <em>(wc_err.3)</em> but
      not the successful tests (neither <em>wc_err.1</em> nor
      <em>wc_err.2</em>). Double click <em>main_err.c</em>, as it contains the most
      likely location of the fault. <!--==================================-->
    </p>
    <p>
      <a name="774894"></a> The source code of <em>main_err.c</em> with the red
      spot selected is displayed in <a href="xslice.html#774894">Figure
      13-4</a>. 
	  
	<a name="774891"></a>          
    <div class="figure">
		<a href="xslice.frm.anc3.gif"><img src="xslice.frm.anc3.gif"></a>
        <div>Figure 13-4 Possible locations of faults in <em>main_err.c</em></div>
    </div>
	  
	  The scroll bar is a thumbnail sketch of the entire file
      indicating there is one red spot. Clicking with the left mouse button at
      the spot in the scroll bar brings the corresponding region of the file
      into the source window. You can also drag the mouse up or down the scroll bar with the left
      mouse button pressed to rapidly scroll up or down the file. 
    </p>
	
    <p>
      <a name="785671">Analysis of the code in</a> <a href=
      "xslice.html#774894">Figure 13-4</a> reveals that the blocks highlighted
      in red contain the fault: the second argument in the call to <em>print</em> 
	  is incorrectly specified as <em>dochar</em> instead of <em>doword</em>. With the help of <em>xSlice</em> and a careful selection of the successful and
      failed tests, this example shows that program maintainers can quickly
      locate faults by examining a reduced set of code instead of the entire
      program.
    </p>
    <p>
      <a name="785684"></a>
    </p>
    <p>
      <a name="786231"></a>
    </p>
    <p>
      <a name="786232"></a>
    </p>
    <p>
      <a name="786233">To quit <em>xSlice</em>, click
      on the "<em>File</em>" button in the top button bar, then select
      "<em>exit</em>".</a>
    </p>

    <h2>
      <a>Tutorial Submission</a>
    </h2>

    <p>
    	<font color="red"> Get the screenshot similar to Figure 13-4, and sent it to TA.
    </p>

    <p>
      <a name="774686"></a>
    </p>
    <hr>
    <br>
		<a href="coverpage.html">[Top]</a> 
		<a href="xvue.html">[Prev]</a>
		<a href="appendixB.html">[Next]</a> 
		<a href="sqatoolIX.html">[Index]</a> 
		<a href="sqatoolTOC.html">[TOC]</a>
    <hr>
    <br>
    <br>
	</div>
  </body>
</html>
